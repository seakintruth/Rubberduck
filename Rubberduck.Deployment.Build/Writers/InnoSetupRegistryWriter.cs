using System;
using System.Collections.Generic;
using System.Globalization;
using System.Linq;
using Microsoft.Win32;
using Rubberduck.Deployment.Build.Structs;

namespace Rubberduck.Deployment.Build.Writers
{
    public class InnoSetupRegistryWriter : IRegistryWriter
    {
        private readonly List<string> _registryEntries = new List<string>();

        // Those set of const should correspond to the defined
        // functions in the .iss script so that they can be expanded
        // at the install time. 
        private const string InstallPathVariable = "{code:GetInstallPath}";
        private const string DllPathVariable = "{{code:GetDllPath|{0}}}";
        private const string Tlb32PathVariable = "{{code:GetTlbPath32|{0}}}";
        private const string Tlb64PathVariable = "{{code:GetTlbPath64|{0}}}";

        private string _dllName;
        private string _tlb32Name;
        private string _tlb64Name;

        public InnoSetupRegistryWriter()
        {
            // Add a comment header
            _registryEntries.Add($@"; Autogenerated by InnoSetupRegistryWriter on {DateTime.UtcNow.ToString("yyyy-MM-dd hh:mm:ss", CultureInfo.InvariantCulture)}");
        }

        public string Write(IOrderedEnumerable<RegistryEntry> entries, string dllName, string tlb32Name, string tlb64Name)
        {
            _dllName = dllName;
            _tlb32Name = tlb32Name;
            _tlb64Name = tlb64Name;

            //Root: "HKCU"; Subkey: "subkey"; ValueType: string; ValueName: "value"; ValueData: "data"; Flags: deletekey uninsdeletekey
            foreach (var entry in entries)
            {
                const string flags = "uninsdeletekey";
                
                var snippet =
                    $@"Subkey: ""{Quote(entry.Key)}""; ValueType: {ConvertValueType(entry.Type)}; ValueName: ""{Quote(entry.Name)}""; ValueData: ""{Quote(ReplacePlaceholder(entry.Value, entry.Bitness))}""; Flags: {flags};";

                switch (entry.Bitness)
                {
                    case Bitness.IsAgnostic:
                        _registryEntries.Add($@"Root: ""HKCU64""; {snippet} Check: IsWin64 and not InstallAllUsers");
                        _registryEntries.Add($@"Root: ""HKCU""; {snippet} Check: not IsWin64 and not InstallAllUsers");
                        _registryEntries.Add($@"Root: ""HKLM64""; {snippet} Check: IsWin64 and InstallAllUsers");
                        _registryEntries.Add($@"Root: ""HKLM""; {snippet} Check: not IsWin64 and InstallAllUsers");
                        break;
                    case Bitness.IsPlatformDependent:
                        _registryEntries.Add($@"Root: ""HKCU64""; {snippet} Check: IsWin64 and not InstallAllUsers");
                        _registryEntries.Add($@"Root: ""HKCU32""; {snippet} Check: IsWin64 and not InstallAllUsers");
                        _registryEntries.Add($@"Root: ""HKCU""; {snippet} Check: not IsWin64 and not InstallAllUsers");
                        _registryEntries.Add($@"Root: ""HKLM64""; {snippet} Check: IsWin64 and InstallAllUsers");
                        _registryEntries.Add($@"Root: ""HKLM32""; {snippet} Check: IsWin64 and InstallAllUsers");
                        _registryEntries.Add($@"Root: ""HKLM""; {snippet} Check: not IsWin64 and InstallAllUsers");
                        break;
                    case Bitness.Is64Bit:
                        _registryEntries.Add($@"Root: ""HKCU""; {snippet} Check: IsWin64 and not InstallAllUsers");
                        _registryEntries.Add($@"Root: ""HKLM""; {snippet} Check: IsWin64 and InstallAllUsers");
                        break;
                    case Bitness.Is32Bit:
                        _registryEntries.Add($@"Root: ""HKCU""; {snippet} Check: not InstallAllUsers");
                        _registryEntries.Add($@"Root: ""HKLM""; {snippet} Check: InstallAllUsers");
                        break;
                }
            }
            
            return string.Join(Environment.NewLine, _registryEntries);
        }

        private string Quote(string value)
        {
            if (string.IsNullOrWhiteSpace(value)
                || value.StartsWith("{code:"))
            {
                return value;
            }

            return value.Replace("{", "{{");
        }

        private string ReplacePlaceholder(string value, Bitness bitness)
        {
            switch (value)
            {
                case PlaceHolders.InstallPath:
                    return InstallPathVariable;
                case PlaceHolders.DllPath:
                    return string.Format(DllPathVariable, _dllName);
                case PlaceHolders.TlbPath:
                    return bitness == Bitness.Is64Bit ? string.Format(Tlb64PathVariable, _tlb64Name) : string.Format(Tlb32PathVariable, _tlb32Name);
                default:
                    return value;
            }
        }

        private string ConvertValueType(RegistryValueKind valueType)
        {
            // ReSharper disable once SwitchStatementMissingSomeCases
            switch (valueType)
            {
                case RegistryValueKind.String:
                    return "string";
                case RegistryValueKind.ExpandString:
                    return "expandsz";
                case RegistryValueKind.Binary:
                    return "binary";
                case RegistryValueKind.DWord:
                    return "dword";
                case RegistryValueKind.MultiString:
                    return "multisz";
                case RegistryValueKind.QWord:
                    return "qword";
                case RegistryValueKind.None:
                    return "none";
                default:
                    throw new ArgumentOutOfRangeException(nameof(valueType), valueType, null);
            }
        }
    }
}
